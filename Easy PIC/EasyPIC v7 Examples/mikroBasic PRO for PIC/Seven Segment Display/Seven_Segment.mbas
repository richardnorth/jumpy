' *
' * Project name:
'     Seven Segment Display (The 'Hello World' example for the Seven Segment Display)
' * Copyright:
'     (c) Mikroelektronika, 2011.
' * Revision History:
'     20110929:
'       - initial release (FJ);
' * Description:
'     This code demonstrates how to display number on one 7-segment display
'     (common cathode). Display is connected to PORTD (RD0..RD7, segment A to
'     RD0, segment B to RD1, etc); common cathode is connected to the pin RA0 on
'     PORTA. Number is incremented every 1s.
' * Test configuration:
'     MCU:             PIC18F45K22
'                      http://ww1.microchip.com/downloads/en/DeviceDoc/41412D.pdf
'     Dev.Board:       EasyPIC7 - ac:7SEG
'                      http://www.mikroe.com/eng/products/view/757/easypic-v7-development-system/
'     Oscillator:      HS-PLL 32.0000 MHz, 8.0000 MHz Crystal
'     Ext. Modules:    None.
'     SW:              mikroBasic PRO for PIC
'                      http://www.mikroe.com/eng/products/view/9/mikrobasic-pro-for-pic/
' * NOTES:
'     - Turn on Seven Segment Display switches SW4.1, SW4.2, SW4.3 and SW4.4. (board specific)
' *

program Seven_Segment_Display

dim shifter, portd_index as byte
    digit, number as word
    portd_array as byte[4]

sub function mask(dim num as word) as word
  select case num
    case 0
      result= $3F
    case 1
      result= $06
    case 2
      result= $5B
    case 3
      result= $4F
    case 4
      result= $66
    case 5
      result= $6D
    case 6
      result= $7D
    case 7
      result= $07
    case 8
      result= $7F
    case 9
      result= $6F
  end select
end sub

sub procedure interrupt
  LATA = 0                          ' turn off all 7seg displays
  LATD = portd_array[portd_index]   ' bring appropriate value to PORTD
  LATA = shifter                    ' turn on appropriate 7seg. display

  ' move shifter to next digit
  shifter= shifter << 1
  if (shifter > 8) then
    shifter = 1
  end if
  ' increment portd_index
  Inc(portd_index)
  if (portd_index > 3) then
    portd_index = 0                 ' turn on 1st, turn off 2nd 7seg.
  end if
  TMR0L = 0                         ' reset TIMER0 value
  TMR0IF_bit = 0                    ' Clear TMR0IF
end sub

main:
  ANSELA = 0          ' Configure PORTA pins as digital
  ANSELD = 0          ' Configure PORTD pins as digital

  TRISA = 0           ' Configure PORTA as output
  LATA = 0            ' Clear PORTA
  TRISD = 0           ' Configure PORTD as output
  LATD = 0            ' Clear PORTD

  T0CON = 0xC4        ' Set TMR0 in 8bit mode, assign prescaler to TMR0
  TMR0L = 0           ' clear TMROL
  digit = 0
  portd_index = 0
  shifter = 1

  number = 1234       ' Initial number value
  GIE_bit = 1  
  TMR0IE_bit = 1

  while TRUE

    digit = number / 1000              	' extract thousands digit
    portd_array[3] = mask(digit)        ' and store it to PORTD array
    digit = (number / 100) mod 10       ' extract hundreds digit
    portd_array[2] = mask(digit)        ' and store it to PORTD array
    digit = (number / 10) mod 10        ' extract tens digit
    portd_array[1] = mask(digit)        ' and store it to PORTD array
    digit = number mod 10               ' extract ones digit
    portd_array[0] = mask(digit)        ' and store it to PORTD array

    Delay_ms(1000)                    	' one second delay

    Inc(number)                         ' increment number
    if (number > 9999) then
      number = 0
    end if
  wend                            			' endless loop
end.