' *
' * Project name:
'     TouchPanelWrite (Demo for working with TouchPanel Controller)
' * Copyright:
'     (c) Mikroelektronika, 2011.
' * Revision History:
'     20110929:
'       - initial release (FJ);
' * Description:
'     This code works with TouchPanel and GLCD. Two digital output and
'     two analog input signals are used for communication with TouchPanel.
'     This example is for writing on the screen, calibration constants for touch
'     panel are set via library function.
' * Test configuration:
'     MCU:             PIC18F45K22
'                      http://ww1.microchip.com/downloads/en/DeviceDoc/41412D.pdf
'     Dev.Board:       EasyPIC7 - ac:Touch_Panel
'                      http://www.mikroe.com/eng/products/view/757/easypic-v7-development-system/
'     Oscillator:      HS-PLL 32.0000 MHz, 8.0000 MHz Crystal
'     Ext. Modules:    GLCD 128x64, Touch Panel
'                      http://www.mikroe.com/eng/products/view/277/various-components/
'     SW:              mikroBasic PRO for PIC
'                      http://www.mikroe.com/eng/products/view/9/mikrobasic-pro-for-pic/
' * Notes:
'     - Turn on GLCD backlight switch SW4.6. (board specific)
'     - Turn on TouchPanel Controller switches SW3.5, SW3.6, SW3.7 and SW3.8. (board specific)
'     - Turn off PORTA LEDs SW3.1. (board specific)
' *

program TouchPanelWrite

' Glcd module connections
dim GLCD_DataPort as byte at PORTD

dim GLCD_CS1 as sbit at LATB0_bit
    GLCD_CS2 as sbit at LATB1_bit
    GLCD_RS  as sbit at LATB2_bit
    GLCD_RW  as sbit at LATB3_bit
    GLCD_EN  as sbit at LATB4_bit
    GLCD_RST as sbit at LATB5_bit

dim GLCD_CS1_Direction as sbit at TRISB0_bit
    GLCD_CS2_Direction as sbit at TRISB1_bit
    GLCD_RS_Direction  as sbit at TRISB2_bit
    GLCD_RW_Direction  as sbit at TRISB3_bit
    GLCD_EN_Direction  as sbit at TRISB4_bit
    GLCD_RST_Direction as sbit at TRISB5_bit
' End Glcd module connections

' Touch Panel module connections
dim DriveA as sbit at LATC0_bit
    DriveB as sbit at LATC1_bit
    DriveA_Direction as sbit at TRISC0_bit
    DriveB_Direction as sbit at TRISC1_bit
' end Touch Panel module connections

dim write_erase as bit
    pen_size as byte
    x_coord, y_coord as word
    write_msg, clear_msg, erase_msg as char[5]           ' GLCD menu messages

sub procedure Initialize()
  ANSELA = 3             ' Configure AN0 and AN1 pins as analog
  ANSELB = 0             ' Configure PORTB pins as digital
  ANSELC = 0             ' Configure PORTC pins as digital
  ANSELD = 0             ' Configure PORTD pins as digital
  TRISA  = 3             ' Configure AN0 and AN1 pins as input

  Glcd_Init()                 ' Initialize GLCD
  Glcd_Fill(0)                ' Clear GLCD
  ADC_Init()                  ' Initialize ADC
  TP_Init(128, 64, 0, 1)      ' Initialize touch panel
  TP_Set_ADC_Threshold(900)   ' Set touch panel ADC threshold
end sub

main:
  write_msg = "WRITE"
  clear_msg = "CLEAR"
  erase_msg = "ERASE"

  Initialize()

  ' You can get calibration constants using touch panel calibration example
  TP_Set_Calibration_Consts(60, 912, 132, 871)      ' Set calibration constants

  Glcd_Write_Text("WRITE ON SCREEN", 20, 5, 1)
  Delay_ms(1000)
  Glcd_Fill(0)

  Glcd_Fill(0)
  Glcd_V_Line(0,7,0,1)
  Glcd_Write_Text(clear_msg,1,0,0)
  Glcd_V_Line(0,7,97,1)
  Glcd_Write_Text(erase_msg,98,0,0)

  ' Pen Menu:
  Glcd_Rectangle(41,0,52,9,1)
  Glcd_Box(45,3,48,6,1)
  Glcd_Rectangle(63,0,70,7,1)
  Glcd_Box(66,3,67,4,1)
  Glcd_Rectangle(80,0,86,6,1)
  Glcd_Dot(83,3,1)

  write_erase = 1
  pen_size = 1

  while (TRUE)
      if (TP_Press_Detect() <> 0) then
        ' After a PRESS is detected read X-Y and convert it to 128x64 space
        if (TP_Get_Coordinates(@x_coord, @y_coord) = 0) then
          if ((x_coord < 31) and (y_coord < 8)) then
            Glcd_Fill(0)

            ' Pen Menu:
            Glcd_Rectangle(41,0,52,9,1)
            Glcd_Box(45,3,48,6,1)
            Glcd_Rectangle(63,0,70,7,1)
            Glcd_Box(66,3,67,4,1)
            Glcd_Rectangle(80,0,86,6,1)
            Glcd_Dot(83,3,1)

            Glcd_V_Line(0,7,0,1)
            Glcd_Write_Text(clear_msg,1,0,0)
            Glcd_V_Line(0,7,97,1)
            if (write_erase) then
              Glcd_Write_Text(erase_msg,98,0,0)
            else
              Glcd_Write_Text(write_msg,98,0,0)
            end if
          end if

          ' If write/erase is pressed
          if ((x_coord > 96) and (y_coord < 8)) then
            if (write_erase) then
              write_erase = 0
              Glcd_Write_Text(write_msg,98,0,0)
              Delay_ms(500)
            else
              write_erase = 1
              Glcd_Write_Text(erase_msg,98,0,0)
              Delay_ms(500)
            end if
          end if

          ' If pen size is selected
          if ((x_coord >= 41) and (x_coord <= 52) and (y_coord <= 9)) then
            pen_size = 3
          end if

          if ((x_coord >= 63) and (x_coord <= 70) and (y_coord <= 7)) then
            pen_size = 2
          end if

          if ((x_coord >= 80) and (x_coord <= 86) and (y_coord <= 6)) then
            pen_size = 1
          end if

          if (y_coord < 11) then
            continue
          end if

          select case pen_size
            case 1
              if ( (x_coord >= 0) and (y_coord >= 0) and (x_coord <= 127) and (y_coord <= 63) ) then
                 Glcd_Dot(x_coord, y_coord, write_erase)
              end if
            case 2
              if ( (x_coord >= 0) and (y_coord >= 0) and (x_coord <= 127-1) and (y_coord <= 63-1) ) then
                 Glcd_Box(x_coord, y_coord, x_coord + 1, y_coord + 1, write_erase)
              end if

            case 3
              if ( (x_coord >= 1) and (y_coord >= 1) and (x_coord <= 127-2) and (y_coord <= 63-2) ) then
                 Glcd_Box(x_coord-1, y_coord-1, x_coord + 2, y_coord + 2, write_erase)
              end if
          end select

        end if
      end if
    wend
end.